GOAL_STATE = (1, 2, 3, 4, 5, 6, 7, 8, 0)

MOVES = {
    'UP': -3,
    'DOWN': 3,
    'LEFT': -1,
    'RIGHT': 1
}

def is_valid_move(pos, move):
    if move == 'UP' and pos < 3:
        return False
    if move == 'DOWN' and pos > 5:
        return False
    if move == 'LEFT' and pos % 3 == 0:
        return False
    if move == 'RIGHT' and (pos + 1) % 3 == 0:
        return False
    return True

def move_tile(state, move):
    new_state = list(state)
    idx = new_state.index(0)
    if not is_valid_move(idx, move):
        return None
    swap_idx = idx + MOVES[move]
    new_state[idx], new_state[swap_idx] = new_state[swap_idx], new_state[idx]
    return tuple(new_state)

def get_successors(state):
    successors = []
    for move in MOVES:
        new_state = move_tile(state, move)
        if new_state:
            successors.append(new_state)
    return successors

# ----------------- IDS (Iterative Deepening Search) -----------------
def dls(state, depth):
    stack = [(state, [])]
    visited = set()

    while stack:
        curr_state, path = stack.pop()
        if curr_state in visited:
            continue
        visited.add(curr_state)

        if curr_state == GOAL_STATE:
            return path + [curr_state]

        if len(path) >= depth:
            continue

        for succ in get_successors(curr_state):
            stack.append((succ, path + [curr_state]))
   
    return None

def ids(start_state, max_depth=50):
    for depth in range(max_depth + 1):
        result = dls(start_state, depth)
        if result:
            return result
    return None

# ----------------- DFS (Depth-First Search) -----------------
def dfs(start_state, max_depth=50):
    stack = [(start_state, [])]
    visited = set()

    while stack:
        curr_state, path = stack.pop()
        if curr_state in visited:
            continue
        visited.add(curr_state)

        if curr_state == GOAL_STATE:
            return path + [curr_state]

        if len(path) >= max_depth:  # depth cutoff
            continue

        for succ in get_successors(curr_state):
            stack.append((succ, path + [curr_state]))
    
    return None

# ----------------- Utility Functions -----------------
def print_path(path):
    print("Number of steps:", len(path) - 1)
    for state in path:
        for i in range(0, 9, 3):
            print(state[i:i+3])
        print()

def get_user_input():
    print("Enter the initial 8-puzzle state row by row.")
    print("Use digits 0-8 exactly once (0 is the blank). Example input for one row: 1 2 3")
    user_values = []

    while len(user_values) < 9:
        try:
            row_input = input(f"Row {len(user_values)//3 + 1}: ").strip()
            row = list(map(int, row_input.split()))
            if len(row) != 3:
                print("Please enter exactly 3 numbers.")
                continue
            user_values.extend(row)
        except ValueError:
            print("Invalid input. Please enter numbers only.")

    if sorted(user_values) != list(range(9)):
        print("The puzzle must contain all digits from 0 to 8 exactly once.\nLet's try again.")
        return get_user_input()

    print("\nPuzzle input accepted!\n")
    return tuple(user_values)

# ----------------- Main -----------------
if __name__ == "__main__":
    start_state = get_user_input()
    print("=== Choose Algorithm ===")
    print("1. IDS (Iterative Deepening Search)")
    print("2. DFS (Depth-First Search)")
    choice = input("Enter choice (1/2): ").strip()

    if choice == "1":
        print("\n=== Solving with IDS ===")
        solution = ids(start_state)
    else:
        print("\n=== Solving with DFS ===")
        solution = dfs(start_state)

    if solution:
        print_path(solution)
    else:
        print("No solution found within depth limit.")
