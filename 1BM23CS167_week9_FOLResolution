from copy import deepcopy

# ---------------------------------------------------------
# Utility Functions
# ---------------------------------------------------------

def is_variable(x):
    return isinstance(x, str) and x[0].islower()

def substitute(subst, expr):
    """Apply substitution to a literal."""
    if isinstance(expr, str):
        return subst.get(expr, expr)
    pred = expr[0]
    args = [substitute(subst, a) for a in expr[1:]]
    return (pred, *args)

def negate(lit):
    """Negate a literal tuple ('P',x) → ('~P',x)."""
    if lit[0].startswith("~"):
        return (lit[0][1:],) + lit[1:]
    else:
        return ("~" + lit[0],) + lit[1:]

def occurs_check(var, x, subst):
    """Avoid infinite recursive substitutions."""
    if var == x:
        return True
    if isinstance(x, tuple):
        return any(occurs_check(var, a, subst) for a in x[1:])
    if is_variable(x) and x in subst:
        return occurs_check(var, subst[x], subst)
    return False

# ---------------------------------------------------------
# Unification
# ---------------------------------------------------------

def unify(x, y, subst=None):
    if subst is None:
        subst = {}

    if x == y:
        return subst

    if is_variable(x):
        return unify_var(x, y, subst)
    if is_variable(y):
        return unify_var(y, x, subst)

    if isinstance(x, tuple) and isinstance(y, tuple) and x[0] == y[0]:
        if len(x) != len(y):
            return None
        for a, b in zip(x[1:], y[1:]):
            subst = unify(substitute(subst, a), substitute(subst, b), subst)
            if subst is None:
                return None
        return subst

    return None

def unify_var(var, x, subst):
    if var in subst:
        return unify(subst[var], x, subst)
    if is_variable(x) and x in subst:
        return unify(var, subst[x], subst)
    if occurs_check(var, x, subst):
        return None
    subst[var] = x
    return subst

# ---------------------------------------------------------
# Resolution
# ---------------------------------------------------------

def resolve(ci, cj):
    resolvents = []

    for li in ci:
        for lj in cj:
            # Opposite predicates
            if li[0].startswith("~") != lj[0].startswith("~") and \
               li[0].lstrip("~") == lj[0].lstrip("~"):

                subst = unify(li, negate(lj))

                if subst is not None:
                    new_clause = set()

                    for lit in ci.union(cj):
                        if lit != li and lit != lj:
                            new_clause.add(substitute(subst, lit))

                    resolvents.append(frozenset(new_clause))

    return resolvents

def fol_resolution(kb, query):
    clauses = deepcopy(kb)
    clauses.append({negate(query)})

    print("Initial Clauses:")
    for c in clauses:
        print(" ", c)

    print("\nResolving...\n")

    new = set()

    while True:
        pairs = [(clauses[i], clauses[j]) 
                 for i in range(len(clauses)) 
                 for j in range(i+1, len(clauses))]

        for (ci, cj) in pairs:
            resolvents = resolve(ci, cj)

            for r in resolvents:
                if not r:
                    print("Derived empty clause → contradiction found! ✅")
                    return True

                new.add(r)

        if new.issubset(set(map(frozenset, clauses))):
            print("No new clauses can be generated. ❌")
            return False

        for c in new:
            if c not in clauses:
                print("New clause:", c)
                clauses.append(set(c))

# ---------------------------------------------------------
# Knowledge Base (CNF Clauses)
# ---------------------------------------------------------

KB = [
    {('~Food', 'x'), ('Likes', 'John', 'x')},
    {('Food', 'Apple')},
    {('Food', 'Vegetable')},
    {('~Eats', 'x', 'y'), ('Killed', 'x'), ('Food', 'y')},
    {('Eats', 'Anil', 'Peanut')},
    {('Alive', 'Anil')},
    {('~Eats', 'Anil', 'y'), ('Eats', 'Harry', 'y')},
    {('~Alive', 'x'), ('~Killed', 'x')},
    {('Killed', 'x'), ('Alive', 'x')}
]

query = ('Likes', 'John', 'Peanut')

# ---------------------------------------------------------
# Run
# ---------------------------------------------------------

proved = fol_resolution(KB, query)

if proved:
    print("\n✅ Proven: John likes peanuts.")
else:
    print("\n❌ Could not prove the query.")
